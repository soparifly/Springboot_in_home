# IOC, DI, 그리고 컨테이너

제어의 역전 IOC(Inversion of Contorl)
제어권이 개발자가아닌 프레임워크에서 진행되는것
* 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버구현객체를 생성하고, 연결하고 실행했다.
* 구현 객체가 프로그램 제어 흐름을 스스로 조종했다. 개발자입장에서는 자연스러운 흐름
* AppConfig 가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다
* 프로그램 제어흐름은 이제 AppConfig가 가져간다.
* 예를들어 Impl은 필요한 인터페이스들을 호출하지만 어떤 객체들이 실행되는지 알수없다.
* 프로그램에 대한 제어흐름에 대한 권한은 AppConfig가 가지고있다. 심지어 OrderImpl인터페이스의 다른 구현객체를 생성하고 실행 할 수도있다.
* 그런 사실은 모른체 Impl객체는 묵묵히 자신의 로직을 실행한다
* 제어의 흐름을 직접제어하는것이 아닌 외부에서 관리하는 것을 제어의 역전 IoC라고한다.


제어의 역전
EX)
"프레임워크" -> Junit

반면에 내가 작성한 코드가 직접 제어의 흐름을 담당하면 그것은 프레임워크가 아니라 라이브러리
라이프 사이클 속에서 내가 구현한 코드를 프레임워크에서 자신만의 적절히 알아서 필요한 부분만 호출이 되는것
호출하는 제어권을 넘기는것.

"라이브러리"
내가 작성한 코드가 자바객체를 xml이든 json 로 변환하는 기능을 호출해서 담당하는것


## 의존관계 주입 DI
* Impl은 인터페이스에만 의존한다 실제 어떤 구현 객체가 될지는 모른다
* 의존 관계는 정적인 클래스의 의존관계와 실행시점에 결정되는 동적인 객체(인스턴스)의존관계  둘을 분리해서 생각해야한다
* "정적인 클래스 의존관계"
* 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다.
* 어플리케이션을 실행하지않아도 분석가능하다
* 
* "동적인 객체 인스턴스 의존 관계"
* 실행을 해봐야 알수있는 인스턴스 참조관계
* Impl 객체에서는 인터페이스에만 의존하기때문에 실제로 실행되기전까진 참조된객체가 어떤 의존관계가 되어있는지 모른다
* 외부에서 구현객체를 생성하고 클라이언트에 전달해서 서버와 의존관계가 연결되는것을 의존관계 주입이라고한다
* 객체 인스턴스를 생성하고 참조값을 전달해서 연결한다
* 의존관계주입을 사용하면 클라이언트 코드를 변경하지않고 클라이언트가 호출하는 대상의 타입인스턴스를 변경할 수 있다
* 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할수 있다,