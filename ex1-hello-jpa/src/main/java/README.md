## 양방향 연관관계와 연관관계의 주인
* FK 로인한 양방향 연관관계 진행
* mappedBy
  * 객체와 테이블이 관계를 맺는 차이
    * 객체는 연관관계가 2가지가있다
    * 회원-> 팀 연관관계 (단)
    * 팀 -> 회원 연관관계 (단)
  
  * 테이블 연관관계 = 1개
  * 회원 <-> 팀의 연관관계 1개 (양방향)
  * 
  ### 객체의 양방향 연관관계
    * 객체의 양방향 관계는 사실 양방향관계가 아니라 사실 서로다른 단방향 관계 2개이다.
      * 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야한다
      * A ->B(a.getA())
      * B ->A(b.getA())
      * class A {
      * B b;
      * }
      * class B {
      * A a;
      * }

  ### 테이블의 양방향  연관관계
  * 테이블은 외래키 하나로 두 테이블의 연관관계를 관리
  * MEMBER.TEAM_ID 외래키 하나로 양방향 연관관계 가짐
    * (양쪽으로 조인할 수 있다.)
    * SELECT * FROM MEMBER M
      * JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
    * SELECT * FROM MEMBER M 
      * JOIN MEMBER M ON T.TEAM_ID = M.TEAM_ID
  
### 연관관계의 주인

    양방향 매핑의 규칙  
* 객체의 두관계중 하나를 연관관계의 주인으로 지정
* 연관관계의 주인만이 외래키를 관리( 등록, 수정
* 주인이 아닌쪽은 읽기만 가능
* 주인은 mappedBy 속성 사용X
* 주인이 아니면 mappedBy 속성으로 주인을 지정해준다 (주인의 필드명)
* 주인으로 선택하는것
* 외래키가 있는 곳을 주인으로 정해라
* 여기는 Member.team이 연관관계의 주인
* 가짜매핑 List members 읽기만 가능
* 이유, 성능이슈/ 인서트할때 한방쿼리 / DB입장에서 외래키가 있는곳이 N이다
* 1:N이 될때 DB 에 N쪽이 연관관계의 주인이 되는것이다 .
* 설계가 깔끔해짐
* 외래키와 같은테이블에서 관리가 됨
* 직관적인 인식이가능해짐

### 다대일 
* 다대일 관계의 반대방향은 항상 일대다 관계고 일대다 관계의 반대방향은 항상 다대일 관계다.
* 객체의 양방향 관계에서 연관관계의 주인은 항상 다쪽
* 양방향은 외래키가 있는 쪽이 연관관계의 주인이다
* 일대다 다대일 연관관계는 항상 다(N)에 외래키가 있다, 
  * 여기서는 다쪽인 MEMBER 테이블이 외래 키를 가지고 있으므로 Member.team이 연관관계의 주인이다.
  * JPA는 외래키를 관리할 때 연관관계의 주인만 사용한다
  * 주인이 아닌 Team.members는 조회를 위한 JPQl 이나 객체 그래프를 탐색할 때 사용한다
* 양방향 연관관계는 항상 서로를 참조해야한다
  * 양방향 연관관계는 항상 서로를 참조해야한다. 어느한쪽만 참조하면 양방향 연관관계가 성립되지않는다.
  * 항상 서로 참조하게 하려면 연관관계 편의 메소드를 작성하는 것이 좋은데. 회원의 setTeam(), 팀의 addMember()
  * 메소드가 이런편의 메소드들이다. 편의 메소드는 한곳에만 작성하거나 양쪽 다 작성할 수 있는데 
  * 양쪽에 다작성하면 무한루프에 빠지므로 주의해야한다. 
  
### 일대다
* 일대다 관계는 다대일 관계의 반대방향이다. 일대다 관계는 엔티티를 하나이상 참조할 수 있으므로 자바 컬렉션인 Collection, List, Set, Map 중에 하나를 사용해야한다.
* 일대 다 단방향[1:N]
* 하나의 팀은 여러회원을 참조할 수 있는데 이런 관계를 일대다 관계라한다.
* 이 매핑은 반대쪽 테이블에 있는 외래키를 관리한다.
* 일대 다 단방향 매핑의 단점
* 일대다 단방향 매핑의 단점은 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점.
* 본인 테이블에 외래키가 있으면 엔티티의 저장과 연관관계 처리를 INSERT SQL 한번으로 끝낼 수 있지만 다른 테이블에 외래키가 있으면
* 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야한다

### 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자
일대다 단방향 매핑을 사용하면 엔티티를 매핑한 테이블이 아닌 다른 테이블의 외래키를 관리해야한다. 
성능 문제도 있지만 관리도 부담스럽다.
문제를 해결하는 좋은 방법은 일대다 단방향 매핑 대신에 다대일 양방향 매핑을 사용하는 것.

### 일대일 [1:1]
* 일대일 관계는 양쪽이 서로 하나의 관계만 가진다.
* 일대일 관계는 그 반대도 일대일 관계다.
* 테이블 관계에서 일대다, 다대일은 항상 다 (N)쪽이 외래키를 가진다
* 반면에 일대일 관계는 주 테이블이나 대상태이블 둘 중 어느 곳에나 외래키를 가질수 있다
* 테이블은 주테이블이든 대상테이블이든 외래키 하나만 있으면 양쪽으로 조회할 수 있다.
* 일대일 관계는 그 반대쪽도 일대일 관계다.
* 따라서 일대일 관계는 주 테이블이나 대상 테이블중에 누가 외래키를 가질지 선택해야한다.

* 주테이블에 외래키 
  * 주객체가 대상 객체를 참조하는 것 처럼 주 테이블에 외래키를 두고 대상 테이블을 참조한다.
  * 외래키를 객체 참조와 비슷하게 사용할 수 있어서 객체지향 개발자들이 선호한다.
  * 이방법의 장점은 주테이블이 외래키를 가지고 있으므로
  * 주테이블 만 확인해도 대상 테이블과 연관관계가 있는지 알수 있다.
  
* 대상 테이블에 외래키
  * 전통적인 데이터베이스 개발자들은 보통 대상 테이블에 외래키 두는것을 선호한다 
  * 이방법의 장점은 테이블 관계를 일대일에서 일대 다 로 변경할때 테이블 구조를 그대로 유지할 수 있다.


### 다대다[N:N]
* 관계형 데이터 베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.
그래서 보통 다대다 관계를 일대다, 다대일 관계로 풀어내는 연결테이블을 사용한다.
중간 연결 테이블을 추가해야한다

* 객체는 테이블과는 다르게 객체 2개로 다대다 관계를 만들 수 있다
* @ManyToMany를 사용하면 다대다 관계를 편리하게 매핑한다
* 다대다 : 단방향
* JoinTable 을 이용한 연결테이블 매핑
* 연결 테이블을 매핑하는 @JoinTable의 속성
  * @JoinTable.name : 연결 테이블을 지정. 여기서는 Member_product테이블을 선택
  * @JoinTable.joinColumns: 현재 방향인 회원과 매핑할 조인컬럼 정보를 지정한다. Member_id로 지정
  * @JoinTable.inverseJoinColumn: 반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다. PRODUCT_ID로 지정
* 다대다 관계를 일대다 다대일 관계로 풀어내기 위해 연결 테이블을 만들 때 식별자를 어떻게 구성할지 선택해야한다
  * 식별관계 : 받아온 식별자를 기본키 + 외래키 (복합키) 로 사용한다.
  * 비 식별 관계: 받아온 식별자는 외래키로만 사용하고 새로운 식별자를 추가한다